import { UiConstraint } from './types';
import { supabase } from '@/integrations/supabase/client';

export async function synthesizeRulesFromReplay(): Promise<void> {
  console.log('ðŸ”§ Synthesizing rules from replay data...');
  
  try {
    // Load recent failure patterns
    const { data: replayItems } = await supabase
      .from('replay_items')
      .select('*')
      .eq('processed', false)
      .in('kind', ['DESIGN_FAIL', 'OCR_FAIL'])
      .order('created_at', { ascending: false })
      .limit(1000);
    
    if (!replayItems?.length) {
      console.log('No unprocessed replay items found');
      return;
    }
    
    // Group failures by rule code
    const failuresByRule = groupFailuresByRule(replayItems);
    
    // Generate guard candidates for each rule
    const guardCandidates = [];
    
    for (const [ruleCode, failures] of Object.entries(failuresByRule)) {
      const guard = await learnGuardFromFailures(ruleCode, failures);
      if (guard && guard.confidence > 0.8) {
        guardCandidates.push(guard);
      }
    }
    
    // Insert/update UI constraints
    for (const guard of guardCandidates) {
      await upsertUiConstraint(guard);
    }
    
    // Mark replay items as processed
    const processedIds = replayItems.map(item => item.id);
    await supabase
      .from('replay_items')
      .update({ processed: true })
      .in('id', processedIds);
    
    console.log(`âœ… Synthesized ${guardCandidates.length} new constraints from ${replayItems.length} replay items`);
    
  } catch (error) {
    console.error('Rule synthesis failed:', error);
  }
}

function groupFailuresByRule(replayItems: any[]): Record<string, any[]> {
  const groups: Record<string, any[]> = {};
  
  for (const item of replayItems) {
    if (item.kind === 'DESIGN_FAIL' && item.payload?.ruleCode) {
      const ruleCode = item.payload.ruleCode;
      if (!groups[ruleCode]) groups[ruleCode] = [];
      groups[ruleCode].push(item);
    }
  }
  
  return groups;
}

async function learnGuardFromFailures(ruleCode: string, failures: any[]): Promise<UiConstraint | null> {
  if (failures.length < 5) return null; // Need minimum failures to learn
  
  // Extract features from failures
  const features = failures.map(failure => extractFeatures(failure.payload));
  
  // Learn decision boundary
  const guard = learnDecisionBoundary(ruleCode, features);
  
  if (!guard) return null;
  
  // Validate guard doesn't block valid designs
  const validationScore = await validateGuard(guard, ruleCode);
  
  return {
    id: '', // Will be generated by database
    scope: guard.scope,
    ruleCode,
    expression: guard.expression,
    reason: guard.reason,
    enabled: validationScore > 0.9, // Only enable high-confidence guards
    confidence: validationScore
  };
}

function extractFeatures(payload: any): Record<string, any> {
  const features: Record<string, any> = {};
  
  if (payload.violation?.details) {
    const details = payload.violation.details;
    
    // Extract numeric features
    if (details.ratio) features.dc_ac_ratio = details.ratio;
    if (details.stringVoltage) {
      features.string_v_min = details.stringVoltage.min;
      features.string_v_max = details.stringVoltage.max;
    }
    if (details.inverterWindow) {
      features.inv_mppt_min = details.inverterWindow.min;
      features.inv_mppt_max = details.inverterWindow.max;
    }
    if (details.headroom) features.backup_headroom = details.headroom;
    if (details.temperature) features.temp_min_c = details.temperature;
  }
  
  return features;
}

function learnDecisionBoundary(ruleCode: string, features: Record<string, any>[]): any {
  // Simple decision stump learning
  // In production, this would use more sophisticated ML
  
  switch (ruleCode) {
    case 'MPPT_VOLTAGE_WINDOW':
      return learnVoltageWindowGuard(features);
    case 'DC_AC_RATIO':
      return learnDcAcRatioGuard(features);
    case 'BACKUP_HEADROOM':
      return learnBackupHeadroomGuard(features);
    default:
      return null;
  }
}

function learnVoltageWindowGuard(features: Record<string, any>[]): any {
  // Find common voltage violation patterns
  const violations = features.filter(f => 
    f.string_v_min < f.inv_mppt_min || f.string_v_max > f.inv_mppt_max
  );
  
  if (violations.length === 0) return null;
  
  return {
    scope: 'STRINGING',
    expression: {
      when: { scope: 'STRINGING' },
      if: {
        'calc.string_v_min': { $gte: '$inv.mppt_min_v' },
        'calc.string_v_max': { $lte: '$inv.mppt_max_v' }
      },
      elseBlock: {
        message: 'String voltage {calc.string_v_min}â€“{calc.string_v_max}V outside inverter MPPT window {inv.mppt_min_v}â€“{inv.mppt_max_v}V at {calc.temp_min_c}Â°C',
        reason: {
          productId: '$inv.id',
          key: 'inv.mppt_min_v',
          expected: { min: '$inv.mppt_min_v', max: '$inv.mppt_max_v' },
          actual: { min: '$calc.string_v_min', max: '$calc.string_v_max' }
        }
      }
    },
    reason: {
      productId: 'generic',
      key: 'mppt_window',
      expected: 'string voltage within MPPT window',
      actual: 'voltage outside window'
    }
  };
}

function learnDcAcRatioGuard(features: Record<string, any>[]): any {
  const ratioViolations = features.filter(f => f.dc_ac_ratio > 1.33 || f.dc_ac_ratio < 0.8);
  
  if (ratioViolations.length === 0) return null;
  
  // Calculate optimal range from data
  const validRatios = features.filter(f => f.dc_ac_ratio >= 0.8 && f.dc_ac_ratio <= 1.33);
  const avgRatio = validRatios.reduce((sum, f) => sum + f.dc_ac_ratio, 0) / validRatios.length;
  
  return {
    scope: 'STACK_PICKER',
    expression: {
      when: { scope: 'STACK_PICKER' },
      if: {
        'calc.dc_ac_ratio': { $gte: 0.8, $lte: 1.33 }
      },
      elseBlock: {
        message: 'DC:AC ratio {calc.dc_ac_ratio} outside recommended range 0.8â€“1.33 (optimal: ~{optimal_ratio})',
        reason: {
          key: 'calc.dc_ac_ratio',
          expected: { min: 0.8, max: 1.33, optimal: Math.round(avgRatio * 10) / 10 },
          actual: '$calc.dc_ac_ratio'
        }
      }
    },
    reason: {
      productId: 'calc',
      key: 'dc_ac_ratio',
      expected: '0.8â€“1.33',
      actual: 'outside range'
    }
  };
}

function learnBackupHeadroomGuard(features: Record<string, any>[]): any {
  const headroomViolations = features.filter(f => f.backup_headroom < 0.1);
  
  if (headroomViolations.length === 0) return null;
  
  return {
    scope: 'STACK_PICKER', 
    expression: {
      when: { scope: 'STACK_PICKER' },
      if: {
        'calc.backup_headroom': { $gte: 0.1 }
      },
      elseBlock: {
        message: 'Battery backup headroom {calc.backup_headroom} below recommended 10% minimum',
        reason: {
          key: 'calc.backup_headroom',
          expected: { min: 0.1 },
          actual: '$calc.backup_headroom'
        }
      }
    },
    reason: {
      productId: 'calc',
      key: 'backup_headroom',
      expected: 'â‰¥10%',
      actual: 'insufficient'
    }
  };
}

async function validateGuard(guard: any, ruleCode: string): Promise<number> {
  // Validate guard doesn't create false positives
  // This would test against known good designs
  
  // For now, return confidence based on rule type
  const confidenceMap = {
    'MPPT_VOLTAGE_WINDOW': 0.95,
    'DC_AC_RATIO': 0.90,
    'BACKUP_HEADROOM': 0.85
  };
  
  return confidenceMap[ruleCode as keyof typeof confidenceMap] || 0.7;
}

async function upsertUiConstraint(constraint: UiConstraint): Promise<void> {
  try {
    const { error } = await supabase
      .from('ui_constraints')
      .upsert({
        scope: constraint.scope,
        rule_code: constraint.ruleCode,
        expression: constraint.expression,
        reason: constraint.reason,
        enabled: constraint.enabled,
        confidence: constraint.confidence
      }, {
        onConflict: 'scope,rule_code'
      });
    
    if (error) throw error;
    
  } catch (error) {
    console.error('Failed to upsert UI constraint:', error);
  }
}

export async function loadRecentFailsByRule(): Promise<Record<string, any[]>> {
  const { data } = await supabase
    .from('replay_items')
    .select('*')
    .eq('kind', 'DESIGN_FAIL')
    .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())
    .order('created_at', { ascending: false });
  
  return groupFailuresByRule(data || []);
}